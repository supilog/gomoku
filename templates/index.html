<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五目並べオンライン</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body { font-family: sans-serif; text-align: center; background: #f0f0f0; margin: 0; padding: 10px; }
        .hidden { display: none; }
        
        .container { 
            max-width: 600px; margin: 0 auto; background: white; padding: 20px; 
            border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); box-sizing: border-box; width: 100%;
        }

        input { padding: 12px; margin: 5px 0; width: 100%; box-sizing: border-box; font-size: 16px; }
        
        button { 
            padding: 12px 20px; margin: 10px 5px; cursor: pointer; 
            background: #007bff; color: white; border: none; border-radius: 4px; font-size: 16px;
        }
        button:hover { background: #0056b3; }
        
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #5a6268; }

        button.spectate { background: #28a745; }
        button.spectate:hover { background: #218838; }
        
        ul { list-style: none; padding: 0; }
        li { padding: 15px 10px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; }
        
        /* Responsive Board */
        #board { 
            display: grid; 
            grid-template-columns: repeat(15, 1fr); 
            gap: 0;
            background: #DEB887; 
            margin: 20px auto; 
            width: 100%; max-width: 500px; 
            aspect-ratio: 1 / 1; 
            border: 5px solid #8B4513; box-sizing: border-box;
        }
        
        .cell { width: 100%; height: 100%; position: relative; cursor: pointer; }
        
        .cell::before { 
            content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: #000; transform: translateY(-50%);
        }
        .cell::after { 
            content: ''; position: absolute; left: 50%; top: 0; height: 100%; width: 1px; background: #000; transform: translateX(-50%);
        }
        
        .stone { 
            width: 80%; height: 80%; border-radius: 50%; z-index: 2; position: absolute; top: 10%; left: 10%;
        }
        .black { background: black; box-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .white { background: white; box-shadow: 1px 1px 2px rgba(0,0,0,0.5); }

        #turn-indicator { font-size: 1.1em; font-weight: bold; margin: 10px 0; padding: 10px; background: #eee; border-radius: 5px; }
        .my-turn { color: #0056b3; background: #e7f1ff !important; border: 2px solid #0056b3; }
        .opponent-turn { color: #555; }
        .spectator-view { color: #28a745; background: #d4edda !important; border: 2px solid #28a745; }

        .table-wrapper { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; min-width: 300px; font-size: 0.9em; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f2f2f2; white-space: nowrap; }

        @media (max-width: 480px) {
            .container { padding: 10px; }
            h1 { font-size: 1.5em; }
            th, td { padding: 4px; font-size: 0.8em; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>五目並べ Online</h1>
    
    <div id="auth-screen">
        <div id="login-form">
            <h2>ログイン</h2>
            <input type="text" id="l_username" placeholder="ID">
            <input type="password" id="l_password" placeholder="Password">
            <button onclick="login()">ログイン</button>
            <p>アカウントがありませんか？ <a href="#" onclick="toggleAuth()">登録へ</a></p>
        </div>
        <div id="register-form" class="hidden">
            <h2>ユーザー登録</h2>
            <input type="text" id="r_username" placeholder="ID (Unique)">
            <input type="password" id="r_password" placeholder="Password">
            <input type="text" id="r_nickname" placeholder="Nickname">
            <button onclick="register()">登録</button>
            <p>既にアカウントをお持ちですか？ <a href="#" onclick="toggleAuth()">ログインへ</a></p>
        </div>
    </div>

    <div id="lobby-screen" class="hidden">
        <h2>ロビー</h2>
        <p>ログイン中: <span id="my-nickname">{{ current_user.nickname if current_user.is_authenticated else '' }}</span></p>
        <button class="secondary" onclick="showHistory()">対戦履歴を見る</button>
        <h3>オンラインユーザー</h3>
        <ul id="user-list"></ul>
    </div>

    <div id="history-screen" class="hidden">
        <h2>対戦履歴 (最新30件)</h2>
        <div class="table-wrapper">
            <table>
                <thead>
                    <tr>
                        <th>日時</th>
                        <th>先手(黒)</th>
                        <th>後手(白)</th>
                        <th>勝者</th>
                    </tr>
                </thead>
                <tbody id="history-table-body"></tbody>
            </table>
        </div>
        <br>
        <button class="secondary" onclick="closeHistory()">ロビーに戻る</button>
    </div>

    <div id="game-screen" class="hidden">
        <h2 id="game-title">対戦中</h2>
        <p>対戦: <span id="game-info"></span></p>
        
        <div id="turn-indicator">ゲーム準備中...</div>
        
        <div id="board"></div>
        <button onclick="backToLobby()">ロビーに戻る</button>
    </div>
</div>

<script>
    const currentUserId = {{ current_user.id if current_user.is_authenticated else 'null' }};
    
    let socket;
    let currentRoom = null;
    let myRoleColor = null; // 1: Black, 2: White, null: Spectator
    let isSpectator = false; // 観戦モードフラグ

    if (currentUserId !== null) {
        initSocket();
    }

    function toggleAuth() {
        document.getElementById('login-form').classList.toggle('hidden');
        document.getElementById('register-form').classList.toggle('hidden');
    }

    async function register() {
        const u = document.getElementById('r_username').value;
        const p = document.getElementById('r_password').value;
        const n = document.getElementById('r_nickname').value;
        const res = await fetch('/register', {
            method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: `username=${u}&password=${p}&nickname=${n}`
        });
        if(res.ok) location.reload();
        else alert('登録失敗: IDが重複している可能性があります');
    }

    async function login() {
        const u = document.getElementById('l_username').value;
        const p = document.getElementById('l_password').value;
        const res = await fetch('/login', {
            method: 'POST', headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: `username=${u}&password=${p}`
        });
        if(res.ok) location.reload();
        else alert('ログイン失敗');
    }

    // --- History Functions ---
    async function showHistory() {
        const res = await fetch('/api/history');
        if(res.ok) {
            const data = await res.json();
            const tbody = document.getElementById('history-table-body');
            tbody.innerHTML = '';
            
            data.history.forEach(game => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${game.time}</td>
                    <td>${game.black}</td>
                    <td>${game.white}</td>
                    <td style="font-weight:bold; color:#d9534f;">${game.winner}</td>
                `;
                tbody.appendChild(tr);
            });

            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('history-screen').classList.remove('hidden');
        }
    }

    function closeHistory() {
        document.getElementById('history-screen').classList.add('hidden');
        document.getElementById('lobby-screen').classList.remove('hidden');
    }

    // --- Socket Logic ---
    function initSocket() {
        socket = io();
        
        socket.on('connect', () => {
            document.getElementById('auth-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        // 【修正】ユーザーリスト更新：対戦中なら「観戦」ボタンを表示
        socket.on('update_user_list', (users) => {
            const list = document.getElementById('user-list');
            list.innerHTML = '';
            users.forEach(u => {
                const li = document.createElement('li');
                
                // 名前部分の生成
                const nameSpan = document.createElement('span');
                nameSpan.textContent = u.nickname;
                if (u.id === currentUserId) nameSpan.textContent += " (あなた)";
                li.appendChild(nameSpan);

                // ボタン部分の生成
                if (u.id !== currentUserId) {
                    if (u.status === 'playing') {
                        // 対戦中なら観戦ボタン
                        const btn = document.createElement('button');
                        btn.textContent = '観戦する';
                        btn.className = 'spectate'; // 緑色のボタン
                        btn.onclick = () => socket.emit('join_spectate', {room_id: u.room_id});
                        li.appendChild(btn);
                    } else {
                        // 待機中なら対戦申込ボタン
                        const btn = document.createElement('button');
                        btn.textContent = '対戦申込';
                        btn.onclick = () => socket.emit('challenge_request', {target_id: u.id});
                        li.appendChild(btn);
                    }
                } else if (u.status === 'playing') {
                     // 自分が対戦中と判定されている場合の表示（再接続時など）
                     const statusSpan = document.createElement('span');
                     statusSpan.textContent = ' [対戦中]';
                     statusSpan.style.color = 'red';
                     li.appendChild(statusSpan);
                }
                
                list.appendChild(li);
            });
        });

        socket.on('receive_challenge', (data) => {
            if(confirm(`${data.challenger_name} から対戦申し込みが届きました。受けますか？`)) {
                socket.emit('challenge_response', {accepted: true, challenger_id: data.challenger_id});
            } else {
                socket.emit('challenge_response', {accepted: false, challenger_id: data.challenger_id});
            }
        });
        
        socket.on('challenge_declined', (data) => {
            alert(data.msg);
        });

        // 通常の対戦開始
        socket.on('game_start', (data) => {
            currentRoom = data.room_id;
            isSpectator = false;
            socket.emit('join_game_room', {room_id: currentRoom});
            
            showGameScreen();
            
            document.getElementById('game-title').innerText = "対戦中";
            document.getElementById('game-info').innerText = `VS ${data.opponent}`;
            
            initBoard();
            myRoleColor = (data.role === 'black') ? 1 : 2;
            updateTurn(1); 
        });

        // 【追加】観戦開始イベント
        socket.on('spectate_start', (data) => {
            currentRoom = data.room_id;
            isSpectator = true; // 観戦モードON
            myRoleColor = null;

            showGameScreen();
            
            document.getElementById('game-title').innerText = "観戦モード";
            document.getElementById('game-info').innerText = `${data.black_name} (黒) VS ${data.white_name} (白)`;
            
            // 盤面の再現
            initBoard();
            const board = data.board;
            for(let r=0; r<15; r++){
                for(let c=0; c<15; c++){
                    if(board[r][c] !== 0) drawStone(r, c, board[r][c]);
                }
            }
            updateTurn(data.current_turn);
        });

        socket.on('update_board', (data) => {
            drawStone(data.row, data.col, data.color);
            const nextTurnColor = (data.color === 1) ? 2 : 1;
            updateTurn(nextTurnColor);
        });

        socket.on('game_over', (data) => {
            let msg;
            if (isSpectator) {
                // 観戦者向けのメッセージ (IDから名前解決はしていないため簡易表示)
                msg = "勝負あり！ ゲームが終了しました。";
            } else {
                msg = (data.winner === currentUserId) ? "あなたの勝ちです！" : "あなたの負けです...";
            }
            
            setTimeout(() => {
                alert(msg);
                backToLobby();
            }, 100);
        });
    }

    function showGameScreen() {
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('history-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
    }
    
    function backToLobby() {
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('lobby-screen').classList.remove('hidden');
        document.getElementById('board').innerHTML = '';
        
        isSpectator = false; // フラグリセット
        currentRoom = null;
        
        // ソケット通信で部屋から退出
        if (socket) {
            socket.emit('back_to_lobby', {room_id: currentRoom}); 
            // ※currentRoomは直前でnullにしてしまうと送れないので注意が必要ですが、
            // サーバー側でsidベースで処理していれば問題ありません。
            // 今回のサーバー実装では data.room_id を見て leave_room するので、
            // 正しくは変数をクリアする前にemitする必要があります。
            // ↓ 修正後のフロー
        }
    }
    // 上記の backToLobby の修正版
    function backToLobby() {
        if (socket && currentRoom) {
            socket.emit('back_to_lobby', {room_id: currentRoom});
        }
        
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('lobby-screen').classList.remove('hidden');
        document.getElementById('board').innerHTML = '';
        
        isSpectator = false;
        currentRoom = null;
    }

    function initBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        for(let r=0; r<15; r++) {
            for(let c=0; c<15; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.onclick = () => clickCell(r, c);
                board.appendChild(cell);
            }
        }
    }

    function clickCell(r, c) {
        if(!currentRoom) return;
        if(isSpectator) return; // 【追加】観戦者は操作不可
        socket.emit('place_stone', {room_id: currentRoom, row: r, col: c});
    }

    function drawStone(r, c, colorVal) {
        const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        if(cell && !cell.hasChildNodes()) {
            const stone = document.createElement('div');
            stone.className = `stone ${colorVal === 1 ? 'black' : 'white'}`;
            cell.appendChild(stone);
        }
    }
    
    function updateTurn(activeUserOrColor) {
        // activeUserOrColor: 対戦中はUser ID (game_start時) や 次の手番User ID が来ることもあるが
        // 今回の spectate_start では 'current_turn' (UserID) が来る
        // update_board では next_turn (UserID) が来る
        // game_start時のみ myRoleColor 設定のために 1 or 2 を使っていたが
        // サーバー実装の update_board は next_turn (UserID) を返している。
        
        // サーバーの update_board 実装再確認:
        // emit('update_board', { ..., 'next_turn': next_turn }) -> next_turnはUserID
        // フロントの update_board 実装:
        // const nextTurnColor = (data.color === 1) ? 2 : 1; -> 色番号(1 or 2)を渡している
        // なので引数は「色番号(1 or 2)」または「UserID」が混在する可能性があるため整理が必要です。
        
        // 今回のフロントエンド実装では、update_board内で「置かれた石の色」から「次の色」を計算して渡しているので
        // 引数は常に「色番号(1:黒, 2:白)」です。
        // spectate_start の時は UserID が来るため、変換が必要です。
        
        const indicator = document.getElementById('turn-indicator');
        
        let activeColor = activeUserOrColor;
        
        // もしUserIDが渡ってきた場合（観戦開始時など）、色番号に変換できないと表示が崩れる。
        // 簡易対応として、spectate_start で current_turn ではなく
        // 「盤面から次の手番を推測する」か、サーバーから「次の手番の色」を送るのが確実です。
        // ここでは update_board と同様のロジックで動くように、
        // Spectator開始時は便宜上 1 (黒) か、盤面の石の数から判断するロジックを入れても良いですが
        // 一旦「ゲーム進行中」表示にします。

        // 観戦モードの場合の表示
        if (isSpectator) {
             indicator.innerText = "観戦中 (プレイヤーが思考中...)";
             indicator.className = 'spectator-view';
             return;
        }

        const isMyTurn = (activeColor === myRoleColor);
        const colorName = (activeColor === 1) ? "黒" : "白";
        
        if (isMyTurn) {
            indicator.innerText = `あなたの番です (${colorName})`;
            indicator.className = 'my-turn';
        } else {
            indicator.innerText = `相手の番です (${colorName})`;
            indicator.className = 'opponent-turn';
        }
    }

</script>
</body>
</html>